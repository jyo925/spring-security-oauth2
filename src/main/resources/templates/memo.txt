* google 로그인
1.코드 받기(인증)
2.엑세스 토큰 받기(정보 접근 권한 생김)
3.사용자 프로필 정보 가져오기
4.정보를 토대로 회원가입 자동 진행 or 추가적인 정보가 필요하면 추가적인 회원 가입 창을 제공


* OAuth 클라이언트 ID 만들기
- 승인된 리디렉션 URI란?
구글 로그인이 완료가 되면 구글 서버에서 인증되었다는 코드를 주는데
코드를 받아서 액세스 토큰을 요청하고
엑세스 토큰을 받아서 사용자 대신 구글 서버에 있는 사용자 정보에 접근할 수 있는 권한이 생기게 됨

엑세스 토큰을 받기 위한 주소 =  승인된 리디렉션 URI
- 주소는 고정
- 해당 주소 맵핑 컨트롤러 필요 X -> 라이브러리(OAuth2 Client)가 알아서 처리

클라이언트 ID, 비밀번호는 노출되지 않도록 하기

//회원가입(강제)
username = google_+ super.loadUser(userRequest).getAttributes()에 있는 sub 정보로
password = "암호화 (아무문자)" -> 이걸로 로그인할게 아니기 때문에 null만 아니면 됨
email = super.loadUser(userRequest).getAttributes()에 있는 정보로
role = "ROLE_USER"


** 스프링 시큐리티 정리
원래 세션 영역이 있고 그 안에 시큐리티 세션이 따로 있음

시큐리티 세션 안에 들어갈 수 있는 타입은 Authentication 객체만 가능, 이 객체가 들어가는 순간 로그인 된 것
-> 필요할 때 마다 컨트롤러에서 DI 할 수 있음
-> Authentication 안에는 UserDetails와 OAuth2User 타입이 들어갈 수 있다.
-> 일반적인 로그인 하면 UserDetails가 생성, OAuth(페이스북, 구글)로 로그인하면 OAuth2User가 생성된다.
-> 일반적인 로그인과 OAuth로그인을 할 때 파라미터를 다르게 받는 메서드를 각각 작성해야 하는 문제가 생김
    -> PrincipalDetails타입(UserDetails를 부모로 하고 있음)을 Oauth2User 타입도 부모로 하도록 변경
    -> PrincipalDetails타입으로만 사용하면 됨


laodUser(), loadUserByUsername()은 오버라이딩해서 구현하지 않아도 자동적으로 작동해서 로그인처리를 해줌
왜 만드나? -> PrincipalDetails타입으로 return 해서 Authentication객체에 저장하기 위함(일반 and OAuth 둘다)
loadUser() 오버라이딩하는 이유는 -> OAuth 로그인인 경우 강제 회원가입을 시키고 Princi~ 타입으로 리턴하기 위함

laodUser(), loadUserByUsername() 함수 종료시 @AuthenticationPrincipal 어노테이션이 만들어진다.
@AuthenticationPrincipal를 사용하여 UserDetailsService에서 리턴한 객체를 컨트롤러의 파라미터로 직접 참조할 수 있다.


****


****